<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>细谈Event Loop # | 进击的切图仔</title>
    <meta name="description" content="">
    
    
    <link rel="preload" href="/assets/css/0.styles.a813c5fa.css" as="style"><link rel="preload" href="/assets/js/app.545fc9af.js" as="script"><link rel="preload" href="/assets/js/2.a898427a.js" as="script"><link rel="preload" href="/assets/js/22.a3a55fb0.js" as="script"><link rel="preload" href="/assets/js/5.d053370d.js" as="script"><link rel="prefetch" href="/assets/js/10.c0413819.js"><link rel="prefetch" href="/assets/js/11.c1a38194.js"><link rel="prefetch" href="/assets/js/12.a0d683fb.js"><link rel="prefetch" href="/assets/js/13.37a09744.js"><link rel="prefetch" href="/assets/js/14.84403a75.js"><link rel="prefetch" href="/assets/js/15.c3293264.js"><link rel="prefetch" href="/assets/js/16.2b2219f9.js"><link rel="prefetch" href="/assets/js/17.714a13e7.js"><link rel="prefetch" href="/assets/js/18.78a686ae.js"><link rel="prefetch" href="/assets/js/19.979d043d.js"><link rel="prefetch" href="/assets/js/20.8a99291d.js"><link rel="prefetch" href="/assets/js/21.6d251f84.js"><link rel="prefetch" href="/assets/js/23.de616130.js"><link rel="prefetch" href="/assets/js/24.3cca3045.js"><link rel="prefetch" href="/assets/js/25.1ef76cd4.js"><link rel="prefetch" href="/assets/js/26.35007419.js"><link rel="prefetch" href="/assets/js/27.c0e1a3bc.js"><link rel="prefetch" href="/assets/js/3.0ed5a1b7.js"><link rel="prefetch" href="/assets/js/4.bcd97617.js"><link rel="prefetch" href="/assets/js/6.b9d7e6bb.js"><link rel="prefetch" href="/assets/js/7.11df48cc.js"><link rel="prefetch" href="/assets/js/8.71eb46b3.js"><link rel="prefetch" href="/assets/js/9.b342fba9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.a813c5fa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">进击的切图仔</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">推荐·博文</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/Node/new.html" class="nav-link">Node</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/new.html" class="nav-link">JS</a></li><li class="dropdown-item"><!----> <a href="/blog/HTML5/new.html" class="nav-link">HTML5</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/new.html" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/blog/数据结构/new.html" class="nav-link">数据结构</a></li><li class="dropdown-item"><!----> <a href="/blog/闲聊/new.html" class="nav-link">闲聊</a></li></ul></div></div><div class="nav-item"><a href="/question/new.html" class="nav-link">Daily question</a></div> <a href="https://github.com/CodeRookie262" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">推荐·博文</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/Node/new.html" class="nav-link">Node</a></li><li class="dropdown-item"><!----> <a href="/blog/JS/new.html" class="nav-link">JS</a></li><li class="dropdown-item"><!----> <a href="/blog/HTML5/new.html" class="nav-link">HTML5</a></li><li class="dropdown-item"><!----> <a href="/blog/Vue/new.html" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/blog/数据结构/new.html" class="nav-link">数据结构</a></li><li class="dropdown-item"><!----> <a href="/blog/闲聊/new.html" class="nav-link">闲聊</a></li></ul></div></div><div class="nav-item"><a href="/question/new.html" class="nav-link">Daily question</a></div> <a href="https://github.com/CodeRookie262" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Blog</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>HTML 5</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading"><span>数据结构</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading open"><span>闲聊</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/闲聊/new.html" class="active sidebar-link">细谈Event Loop #</a></li><li><a href="/blog/闲聊/关于异步的那些坑.html" class="sidebar-link">关于异步的那些坑</a></li><li><a href="/blog/闲聊/前方核能 还可以这样吗.html" class="sidebar-link">前方核能 还可以这样吗</a></li><li><a href="/blog/闲聊/极限挑战 44 道 JS 题目,你对了多少道.html" class="sidebar-link">极限挑战 43道 JS 题目,你对了多少道!</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Question</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="细谈event-loop"><a href="#细谈event-loop" aria-hidden="true" class="header-anchor">#</a> 细谈Event Loop</h1> <p>前段时间对JavaScript的 <strong>Event Loop</strong> (事件循环机制)有些感兴趣,就去查阅了很多关于这方面的文章,感觉受益匪浅,以下是笔者个人对 <strong>Event Loop</strong> 的见解;</p> <blockquote><h5 id="首先-我们得知道-javascript-为什么是单线程而不是多线程"><a href="#首先-我们得知道-javascript-为什么是单线程而不是多线程" aria-hidden="true" class="header-anchor">#</a> 首先,我们得知道 JavaScript 为什么是单线程而不是多线程?</h5></blockquote> <p>   Brendan Eich当初在发明 <code>JavaScript</code> 时为什么不把 <code>JavaScript</code> 设置为多线程开发呢,而偏偏要选择单线程呢,多线程还可以提高效率,单线程的话,同一时间只能做一件事情,会不会有点不合理</p> <p>   其实,Brendan Eich当初把 <code>JS</code>  设置为单线程是有原因的,和它的用途有着密切的关系, <code>JS</code> 的主要用途就是与用户互动以及操作 <code>DOM</code>  .导致它生而为单线程,加入它有两个线程的话,一个线程负责在 <code>DOM</code>  节点上添加内容,一个赋值删除这个节点,这样会导致冲突,带来的是更为复杂的同步问题,所以js只能是单线程,也只能是单线程,不过说 <code>JS</code> 是单线程可以是可以,不过 也可以支持多线程,那就是 <code>NodeJs</code>,在 V10.5.0的 <code>NodeJs</code> 新增了多线程, <code>NodeJs</code> 中可以用 <code>cluster</code> 模块实现多进程，<code>cluster</code> 中 <code>fork()</code> 可以从主进程分裂出子进程.这篇文章主要以单线程为主,暂时就不演示 <code>NodeJs</code> 的多线程操作了.</p> <p>   所以<code>JS</code>为了避免复杂性,从一诞生就是单线程,所以 <code>js</code> 的单线程已成为这门语言的核心特征了</p> <p>   为了利用充分 <code>CPU</code> 的计算能力, <code>HTML5</code> 提出了 <code>Web Worker</code> 标准,允许脚本创建多个线程,但是子线程完全受子线程控制,且不得操作<code>DOM</code>,所以,这个标准并没有改变 <code>JS</code> 单线程的本质,既然提到了这一标准,笔直就来演示一下代码操作吧.</p> <ul><li><strong>index.js</strong></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>    let woker = new Worker(&quot;worker.js&quot;);//创建对象
        
        worker.postMessage(&quot;worker.js收到请回答&quot;);//发送数据
        
        worker.onmessage = function (e){//接收并处理数据
            let res = e.data;//e.data就是worker.js文件发送给index.js的数据
            alert(res);
        }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li><strong>worker.js</strong></li></ul> <div class="language- line-numbers-mode"><pre class="language-text"><code>    self.onmessage = function(e){
        let res = e.data;
        self.postMessage(&quot;over!over!已收到&quot;);
    }
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>以上就是简单的代码演示.</p> <blockquote><h5 id="任务队列"><a href="#任务队列" aria-hidden="true" class="header-anchor">#</a> 任务队列</h5></blockquote> <p>   我们继续回到单线程的问题上来,既然是单线程,这就意味着所有任务都需要在这个线程上排队,只有前一个任务结束才会执行下一个任务,如果前一个任务耗时比较长,例如网络请求,再加上还在2G时代的话,又或者是 <code>I/O</code> 操作的话,那岂不是要一直等到当前任务执行完毕才可以执行下一个任务了吗?假如排队的原因是因为任务的业务逻辑过于复杂/数据处理的数据较为庞大,导致 <code>CPU</code> 忙不过来倒是可以谅解,关键是很多时候 <code>CPU</code> 是空闲的,因为 <code>IO</code>设备很慢,不得不等待起结束后才可以执行下一个任务,设计者在设计之初也意识到这个问题,认为这种情况下完全可以不管IO设备,先把它挂起,运行后面的任务.等其返回了结果,再把挂起的任务继续执行下去.</p> <p>   于是在 <code>JS</code> 的单线程上存在这两种任务,分别是 同步任务(Synchronous)和 异步任务 (Asynchronous)</p> <table><thead><tr><th>任务类别</th> <th>内容</th></tr></thead> <tbody><tr><td>同步任务</td> <td>在主线程上排队执行的任务,只有前一个任务执行完毕才会执行下一个任务</td></tr> <tr><td>异步任务</td> <td>不加入主线程,而是进入 任务队列(task queue)的任务,只有任务队列告知主线程当前队列的某个任务可以执行了,该任务才会进入主线程执行</td></tr></tbody></table> <p><strong>更为具体来说</strong></p> <ol><li><p>所有<code>同步任务</code>都在<code>主线程</code>上执行,形成一个<code>执行栈</code> <code>栈:先进后出/后进先出</code></p></li> <li><p><code>主线程</code>外还有一个<code>任务队列</code>,只要<code>异步任务</code>有了运行结果,就会在<code>任务队列</code>中放置一个事件</p></li> <li><p>只有执行栈中的所有同步任务全部执行完毕,系统才会读取任务队列,看看里边有哪一些事件,然后对应的异步任务就会结束等待状态,进入执行栈,开始执行</p></li> <li><p>主线程会不断执行第三步</p></li></ol> <blockquote><h5 id="事件与回调函数"><a href="#事件与回调函数" aria-hidden="true" class="header-anchor">#</a> 事件与回调函数</h5></blockquote> <ul><li><code>任务队列</code>就是一个事件的队列,每当有异步任务有了运行结果,就会在<code>任务队列</code>中放置一个与之对应的事件,这个事件就表示放置这个事件的异步任务可以进入<code>执行栈</code>了,主线程读取任务队列就是读取里面有哪一些事件</li> <li><code>任务队列</code>中的事件其实可不止<code>IO</code>设备的事件,还包括一些用户产生的事件(比如<code>页面点击</code>,<code>键盘操作</code>等事件).主要指定过<code>回调函数</code>,这些事件发生时就会进入<code>任务队列</code>,等待主线程读取,然后进入<code>执行栈</code>执行.
<em>所谓的回调函数,就是那一些被主线程挂起来的代码,异步任务必须指定回调函数,但主线程执行异步任务,就是执行这些异步任务对应的回调函数.</em>
-<code>任务队列</code>是一个先进后出的数据结构,所以排在前面的事件会被主线程优先读取,主线程的读取基本是自动的,主要执行栈一清空,<code>任务队列</code>里的第一个事件就会进入主线程的,然后在执行栈中执行与第一个事件相对应的异步任务,但是,<code>JS</code>中还存在着定时器,所以主线程首先要检查下执行的时间,因为有些事件只有到了规定的时间才能返回到主线程的</li></ul> <blockquote><p>Event Loop</p></blockquote> <p>   因为之前提到过,主线程读取任务队列中的事件这一过程是循环不断的,所以这种机制称之为 Event Loop(事件循环机制)</p> <p>当主线程运行的时候,会产生堆(Heap)和栈(Stack),栈中的代码会调用各种Web API,让他们在<code>任务队列</code>中加入各种事件(<code>Click</code>,<code>Load</code>,<code>Error等</code>),只要栈中的代码执行完毕,主线程就会去读取<code>任务队列</code>中那些事件的回调函数,执行栈中的代码(<code>同步任务</code>)总是在读取<code>任务队列(异步任务)</code>前执行的,说这么多有点枯燥,举个栗子</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>    <span class="token comment">//在这里就不考虑XHRHttpRequest的兼容性了</span>
    <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XHRHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span>url<span class="token punctuation">)</span>
        xhr<span class="token punctuation">.</span><span class="token function-variable function">onLoad</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
        xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>因为上述代码的send()方法是Ajax往服务器发送数据,所以它属于异步任务,所以也可以有下面这种写法</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code> <span class="token keyword">let</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XHRHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;get&quot;</span><span class="token punctuation">,</span>url<span class="token punctuation">)</span>
        xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        xhr<span class="token punctuation">.</span><span class="token function-variable function">onLoad</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>也就是说,指定函数的部分onload,在send()方法的前后都无所谓,因为它们属于执行栈的一部分,系统总是执行完它们才会去读取<code>任务队列</code></p> <p>ps:以上很绕,要好好理解,笔者我也是搞了很久才有点懂Emmm</p> <blockquote><h5 id="定时器"><a href="#定时器" aria-hidden="true" class="header-anchor">#</a> 定时器</h5></blockquote> <p>   除了放置<code>异步任务</code>的事件,<code>任务队列</code>还可以放置定时事件,即指定某些代码在什么时候执行,这叫做&quot;定时器&quot;(timer)功能,就是定时执行的代码</p> <p>   定时器主要分为两种,一种是<code>setTimeout()</code>和<code>setInterval()</code>,它们的内部的运行机制是完全一样的,唯一不同的就是前者内部的回调函数是一次性执行的,而后者是周期新反复执行的</p> <p>setTimeout()普遍接受两个参数,第一个是回调函数,第二个是推迟执行的毫秒数,第三个以及第三个后的参数为回调函数的参数</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>[ 结果是 1,3,2 ] 可能有人认为它是因为推迟 1s 才执行的原因导致的</p></blockquote> <p>那么我们把推迟的时间调成 0ms 试试看</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><blockquote><p>[ 结果是 1,3,2 ]  这是为什么呢?</p></blockquote> <blockquote><p>因为setTimeout内部的回调函数属于异步任务,所以执行栈会先把<code>同步任务</code>先执行完毕后,才会去执行<code>任务队列</code>的回调函数</p></blockquote> <p>   HTML5标准规定<code>setTimerout</code>的第二个参数即延迟时间的最小值不得低于 4ms ,如果设置的延迟时间低于4ms,就会自动增加. 在此之前,老版本的浏览器都将最短时间设置为 10ms,此外,对于那些DOM操作导致页面重新渲染的部分,通常不会立即执行的,而是每 16ms执行一次,所以同样在操作DOM制作动画的情况下,使用<code>requestAnimationFrame()</code>(请求动画帧)的效果好于用定时器. 另外还有一点就是定时器只是将回调函数插入到任务队列,所以必须要等到当前代码<code>即 执行栈</code>执行完毕,主线程才会去执行他的回调函数,要是当前代码执行耗时过于长,有可能会等待很久才可以执行,所以不能保证定时器内部的回调函数一定会在指定的时间执行</p> <section style="border-top:2px solid #eaecef;padding-top:1rem;margin-top:2rem;"><div><span data-flag-title="Your Article Title" class="leancloud-visitors"><em class="post-meta-item-text">阅读量： </em> <i class="leancloud-visitors-count"></i></span></div> <h3><a href="javascript:;"></a>
    评 论：
  </h3> <div id="vcomments"></div></section></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/数据结构/车门已焊死,带你了解观察者模式和发布订阅模式.html" class="prev">车门已焊死,带你了解观察者模式和订阅发布模式</a></span> <span class="next"><a href="/blog/闲聊/关于异步的那些坑.html">关于异步的那些坑</a>→
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.545fc9af.js" defer></script><script src="/assets/js/2.a898427a.js" defer></script><script src="/assets/js/22.a3a55fb0.js" defer></script><script src="/assets/js/5.d053370d.js" defer></script>
  </body>
</html>
