(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{159:function(s,t,a){"use strict";a.r(t);var n=a(1),e=Object(n.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h1",{attrs:{id:"细谈event-loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#细谈event-loop","aria-hidden":"true"}},[s._v("#")]),s._v(" 细谈Event Loop")]),s._v(" "),a("p",[s._v("前段时间对JavaScript的 "),a("strong",[s._v("Event Loop")]),s._v(" (事件循环机制)有些感兴趣,就去查阅了很多关于这方面的文章,感觉受益匪浅,以下是笔者个人对 "),a("strong",[s._v("Event Loop")]),s._v(" 的见解;")]),s._v(" "),a("blockquote",[a("h5",{attrs:{id:"首先-我们得知道-javascript-为什么是单线程而不是多线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#首先-我们得知道-javascript-为什么是单线程而不是多线程","aria-hidden":"true"}},[s._v("#")]),s._v(" 首先,我们得知道 JavaScript 为什么是单线程而不是多线程?")])]),s._v(" "),a("p",[s._v("   Brendan Eich当初在发明 "),a("code",[s._v("JavaScript")]),s._v(" 时为什么不把 "),a("code",[s._v("JavaScript")]),s._v(" 设置为多线程开发呢,而偏偏要选择单线程呢,多线程还可以提高效率,单线程的话,同一时间只能做一件事情,会不会有点不合理")]),s._v(" "),a("p",[s._v("   其实,Brendan Eich当初把 "),a("code",[s._v("JS")]),s._v("  设置为单线程是有原因的,和它的用途有着密切的关系, "),a("code",[s._v("JS")]),s._v(" 的主要用途就是与用户互动以及操作 "),a("code",[s._v("DOM")]),s._v("  .导致它生而为单线程,加入它有两个线程的话,一个线程负责在 "),a("code",[s._v("DOM")]),s._v("  节点上添加内容,一个赋值删除这个节点,这样会导致冲突,带来的是更为复杂的同步问题,所以js只能是单线程,也只能是单线程,不过说 "),a("code",[s._v("JS")]),s._v(" 是单线程可以是可以,不过 也可以支持多线程,那就是 "),a("code",[s._v("NodeJs")]),s._v(",在 V10.5.0的 "),a("code",[s._v("NodeJs")]),s._v(" 新增了多线程, "),a("code",[s._v("NodeJs")]),s._v(" 中可以用 "),a("code",[s._v("cluster")]),s._v(" 模块实现多进程，"),a("code",[s._v("cluster")]),s._v(" 中 "),a("code",[s._v("fork()")]),s._v(" 可以从主进程分裂出子进程.这篇文章主要以单线程为主,暂时就不演示 "),a("code",[s._v("NodeJs")]),s._v(" 的多线程操作了.")]),s._v(" "),a("p",[s._v("   所以"),a("code",[s._v("JS")]),s._v("为了避免复杂性,从一诞生就是单线程,所以 "),a("code",[s._v("js")]),s._v(" 的单线程已成为这门语言的核心特征了")]),s._v(" "),a("p",[s._v("   为了利用充分 "),a("code",[s._v("CPU")]),s._v(" 的计算能力, "),a("code",[s._v("HTML5")]),s._v(" 提出了 "),a("code",[s._v("Web Worker")]),s._v(" 标准,允许脚本创建多个线程,但是子线程完全受子线程控制,且不得操作"),a("code",[s._v("DOM")]),s._v(",所以,这个标准并没有改变 "),a("code",[s._v("JS")]),s._v(" 单线程的本质,既然提到了这一标准,笔直就来演示一下代码操作吧.")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("index.js")])])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('    let woker = new Worker("worker.js");//创建对象\n        \n        worker.postMessage("worker.js收到请回答");//发送数据\n        \n        worker.onmessage = function (e){//接收并处理数据\n            let res = e.data;//e.data就是worker.js文件发送给index.js的数据\n            alert(res);\n        }\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br")])]),a("ul",[a("li",[a("strong",[s._v("worker.js")])])]),s._v(" "),a("div",{staticClass:"language- line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[s._v('    self.onmessage = function(e){\n        let res = e.data;\n        self.postMessage("over!over!已收到");\n    }\n')])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br")])]),a("p",[s._v("以上就是简单的代码演示.")]),s._v(" "),a("blockquote",[a("h5",{attrs:{id:"任务队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务队列","aria-hidden":"true"}},[s._v("#")]),s._v(" 任务队列")])]),s._v(" "),a("p",[s._v("   我们继续回到单线程的问题上来,既然是单线程,这就意味着所有任务都需要在这个线程上排队,只有前一个任务结束才会执行下一个任务,如果前一个任务耗时比较长,例如网络请求,再加上还在2G时代的话,又或者是 "),a("code",[s._v("I/O")]),s._v(" 操作的话,那岂不是要一直等到当前任务执行完毕才可以执行下一个任务了吗?假如排队的原因是因为任务的业务逻辑过于复杂/数据处理的数据较为庞大,导致 "),a("code",[s._v("CPU")]),s._v(" 忙不过来倒是可以谅解,关键是很多时候 "),a("code",[s._v("CPU")]),s._v(" 是空闲的,因为 "),a("code",[s._v("IO")]),s._v("设备很慢,不得不等待起结束后才可以执行下一个任务,设计者在设计之初也意识到这个问题,认为这种情况下完全可以不管IO设备,先把它挂起,运行后面的任务.等其返回了结果,再把挂起的任务继续执行下去.")]),s._v(" "),a("p",[s._v("   于是在 "),a("code",[s._v("JS")]),s._v(" 的单线程上存在这两种任务,分别是 同步任务(Synchronous)和 异步任务 (Asynchronous)")]),s._v(" "),a("table",[a("thead",[a("tr",[a("th",[s._v("任务类别")]),s._v(" "),a("th",[s._v("内容")])])]),s._v(" "),a("tbody",[a("tr",[a("td",[s._v("同步任务")]),s._v(" "),a("td",[s._v("在主线程上排队执行的任务,只有前一个任务执行完毕才会执行下一个任务")])]),s._v(" "),a("tr",[a("td",[s._v("异步任务")]),s._v(" "),a("td",[s._v("不加入主线程,而是进入 任务队列(task queue)的任务,只有任务队列告知主线程当前队列的某个任务可以执行了,该任务才会进入主线程执行")])])])]),s._v(" "),a("p",[a("strong",[s._v("更为具体来说")])]),s._v(" "),a("ol",[a("li",[a("p",[s._v("所有"),a("code",[s._v("同步任务")]),s._v("都在"),a("code",[s._v("主线程")]),s._v("上执行,形成一个"),a("code",[s._v("执行栈")]),s._v(" "),a("code",[s._v("栈:先进后出/后进先出")])])]),s._v(" "),a("li",[a("p",[a("code",[s._v("主线程")]),s._v("外还有一个"),a("code",[s._v("任务队列")]),s._v(",只要"),a("code",[s._v("异步任务")]),s._v("有了运行结果,就会在"),a("code",[s._v("任务队列")]),s._v("中放置一个事件")])]),s._v(" "),a("li",[a("p",[s._v("只有执行栈中的所有同步任务全部执行完毕,系统才会读取任务队列,看看里边有哪一些事件,然后对应的异步任务就会结束等待状态,进入执行栈,开始执行")])]),s._v(" "),a("li",[a("p",[s._v("主线程会不断执行第三步")])])]),s._v(" "),a("blockquote",[a("h5",{attrs:{id:"事件与回调函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件与回调函数","aria-hidden":"true"}},[s._v("#")]),s._v(" 事件与回调函数")])]),s._v(" "),a("ul",[a("li",[a("code",[s._v("任务队列")]),s._v("就是一个事件的队列,每当有异步任务有了运行结果,就会在"),a("code",[s._v("任务队列")]),s._v("中放置一个与之对应的事件,这个事件就表示放置这个事件的异步任务可以进入"),a("code",[s._v("执行栈")]),s._v("了,主线程读取任务队列就是读取里面有哪一些事件")]),s._v(" "),a("li",[a("code",[s._v("任务队列")]),s._v("中的事件其实可不止"),a("code",[s._v("IO")]),s._v("设备的事件,还包括一些用户产生的事件(比如"),a("code",[s._v("页面点击")]),s._v(","),a("code",[s._v("键盘操作")]),s._v("等事件).主要指定过"),a("code",[s._v("回调函数")]),s._v(",这些事件发生时就会进入"),a("code",[s._v("任务队列")]),s._v(",等待主线程读取,然后进入"),a("code",[s._v("执行栈")]),s._v("执行.\n"),a("em",[s._v("所谓的回调函数,就是那一些被主线程挂起来的代码,异步任务必须指定回调函数,但主线程执行异步任务,就是执行这些异步任务对应的回调函数.")]),s._v("\n-"),a("code",[s._v("任务队列")]),s._v("是一个先进后出的数据结构,所以排在前面的事件会被主线程优先读取,主线程的读取基本是自动的,主要执行栈一清空,"),a("code",[s._v("任务队列")]),s._v("里的第一个事件就会进入主线程的,然后在执行栈中执行与第一个事件相对应的异步任务,但是,"),a("code",[s._v("JS")]),s._v("中还存在着定时器,所以主线程首先要检查下执行的时间,因为有些事件只有到了规定的时间才能返回到主线程的")])]),s._v(" "),a("blockquote",[a("p",[s._v("Event Loop")])]),s._v(" "),a("p",[s._v("   因为之前提到过,主线程读取任务队列中的事件这一过程是循环不断的,所以这种机制称之为 Event Loop(事件循环机制)")]),s._v(" "),a("p",[s._v("当主线程运行的时候,会产生堆(Heap)和栈(Stack),栈中的代码会调用各种Web API,让他们在"),a("code",[s._v("任务队列")]),s._v("中加入各种事件("),a("code",[s._v("Click")]),s._v(","),a("code",[s._v("Load")]),s._v(","),a("code",[s._v("Error等")]),s._v("),只要栈中的代码执行完毕,主线程就会去读取"),a("code",[s._v("任务队列")]),s._v("中那些事件的回调函数,执行栈中的代码("),a("code",[s._v("同步任务")]),s._v(")总是在读取"),a("code",[s._v("任务队列(异步任务)")]),s._v("前执行的,说这么多有点枯燥,举个栗子")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("    "),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("//在这里就不考虑XHRHttpRequest的兼容性了")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" xhr "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("XHRHttpRequest")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        xhr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("open")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"get"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("url"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n        xhr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("onLoad")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n        xhr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("send")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("因为上述代码的send()方法是Ajax往服务器发送数据,所以它属于异步任务,所以也可以有下面这种写法")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("let")]),s._v(" xhr "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("new")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("XHRHttpRequest")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n        xhr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("open")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[s._v('"get"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v("url"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n        xhr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("send")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n        xhr"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[s._v("onLoad")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br")])]),a("p",[s._v("也就是说,指定函数的部分onload,在send()方法的前后都无所谓,因为它们属于执行栈的一部分,系统总是执行完它们才会去读取"),a("code",[s._v("任务队列")])]),s._v(" "),a("p",[s._v("ps:以上很绕,要好好理解,笔者我也是搞了很久才有点懂Emmm")]),s._v(" "),a("blockquote",[a("h5",{attrs:{id:"定时器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定时器","aria-hidden":"true"}},[s._v("#")]),s._v(" 定时器")])]),s._v(" "),a("p",[s._v("   除了放置"),a("code",[s._v("异步任务")]),s._v("的事件,"),a("code",[s._v("任务队列")]),s._v('还可以放置定时事件,即指定某些代码在什么时候执行,这叫做"定时器"(timer)功能,就是定时执行的代码')]),s._v(" "),a("p",[s._v("   定时器主要分为两种,一种是"),a("code",[s._v("setTimeout()")]),s._v("和"),a("code",[s._v("setInterval()")]),s._v(",它们的内部的运行机制是完全一样的,唯一不同的就是前者内部的回调函数是一次性执行的,而后者是周期新反复执行的")]),s._v(" "),a("p",[s._v("setTimeout()普遍接受两个参数,第一个是回调函数,第二个是推迟执行的毫秒数,第三个以及第三个后的参数为回调函数的参数")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("setTimeout")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("blockquote",[a("p",[s._v("[ 结果是 1,3,2 ] 可能有人认为它是因为推迟 1s 才执行的原因导致的")])]),s._v(" "),a("p",[s._v("那么我们把推迟的时间调成 0ms 试试看")]),s._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[s._v("console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("setTimeout")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=>")]),s._v(" console"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\nconsole"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br")])]),a("blockquote",[a("p",[s._v("[ 结果是 1,3,2 ]  这是为什么呢?")])]),s._v(" "),a("blockquote",[a("p",[s._v("因为setTimeout内部的回调函数属于异步任务,所以执行栈会先把"),a("code",[s._v("同步任务")]),s._v("先执行完毕后,才会去执行"),a("code",[s._v("任务队列")]),s._v("的回调函数")])]),s._v(" "),a("p",[s._v("   HTML5标准规定"),a("code",[s._v("setTimerout")]),s._v("的第二个参数即延迟时间的最小值不得低于 4ms ,如果设置的延迟时间低于4ms,就会自动增加. 在此之前,老版本的浏览器都将最短时间设置为 10ms,此外,对于那些DOM操作导致页面重新渲染的部分,通常不会立即执行的,而是每 16ms执行一次,所以同样在操作DOM制作动画的情况下,使用"),a("code",[s._v("requestAnimationFrame()")]),s._v("(请求动画帧)的效果好于用定时器. 另外还有一点就是定时器只是将回调函数插入到任务队列,所以必须要等到当前代码"),a("code",[s._v("即 执行栈")]),s._v("执行完毕,主线程才会去执行他的回调函数,要是当前代码执行耗时过于长,有可能会等待很久才可以执行,所以不能保证定时器内部的回调函数一定会在指定的时间执行")]),s._v(" "),a("Valine")],1)}),[],!1,null,null,null);t.default=e.exports}}]);